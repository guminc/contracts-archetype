/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export type AuthStruct = { key: BytesLike; proof: BytesLike[] };

export type AuthStructOutput = [key: string, proof: string[]] & {
  key: string;
  proof: string[];
};

export type MintTierStruct = {
  numMints: BigNumberish;
  mintDiscount: BigNumberish;
};

export type MintTierStructOutput = [numMints: bigint, mintDiscount: bigint] & {
  numMints: bigint;
  mintDiscount: bigint;
};

export type DiscountStruct = {
  affiliateDiscount: BigNumberish;
  mintTiers: MintTierStruct[];
};

export type DiscountStructOutput = [
  affiliateDiscount: bigint,
  mintTiers: MintTierStructOutput[]
] & { affiliateDiscount: bigint; mintTiers: MintTierStructOutput[] };

export type ConfigStruct = {
  baseUri: string;
  affiliateSigner: AddressLike;
  maxSupply: BigNumberish;
  maxBatchSize: BigNumberish;
  affiliateFee: BigNumberish;
  defaultRoyalty: BigNumberish;
  discounts: DiscountStruct;
};

export type ConfigStructOutput = [
  baseUri: string,
  affiliateSigner: string,
  maxSupply: bigint,
  maxBatchSize: bigint,
  affiliateFee: bigint,
  defaultRoyalty: bigint,
  discounts: DiscountStructOutput
] & {
  baseUri: string;
  affiliateSigner: string;
  maxSupply: bigint;
  maxBatchSize: bigint;
  affiliateFee: bigint;
  defaultRoyalty: bigint;
  discounts: DiscountStructOutput;
};

export type PayoutConfigStruct = {
  ownerBps: BigNumberish;
  platformBps: BigNumberish;
  partnerBps: BigNumberish;
  superAffiliateBps: BigNumberish;
  partner: AddressLike;
  superAffiliate: AddressLike;
  ownerAltPayout: AddressLike;
};

export type PayoutConfigStructOutput = [
  ownerBps: bigint,
  platformBps: bigint,
  partnerBps: bigint,
  superAffiliateBps: bigint,
  partner: string,
  superAffiliate: string,
  ownerAltPayout: string
] & {
  ownerBps: bigint;
  platformBps: bigint;
  partnerBps: bigint;
  superAffiliateBps: bigint;
  partner: string;
  superAffiliate: string;
  ownerAltPayout: string;
};

export type BurnInviteStruct = {
  burnErc721: AddressLike;
  burnAddress: AddressLike;
  tokenAddress: AddressLike;
  price: BigNumberish;
  reversed: boolean;
  ratio: BigNumberish;
  start: BigNumberish;
  end: BigNumberish;
  limit: BigNumberish;
};

export type BurnInviteStructOutput = [
  burnErc721: string,
  burnAddress: string,
  tokenAddress: string,
  price: bigint,
  reversed: boolean,
  ratio: bigint,
  start: bigint,
  end: bigint,
  limit: bigint
] & {
  burnErc721: string;
  burnAddress: string;
  tokenAddress: string;
  price: bigint;
  reversed: boolean;
  ratio: bigint;
  start: bigint;
  end: bigint;
  limit: bigint;
};

export type DutchInviteStruct = {
  price: BigNumberish;
  reservePrice: BigNumberish;
  delta: BigNumberish;
  start: BigNumberish;
  end: BigNumberish;
  limit: BigNumberish;
  maxSupply: BigNumberish;
  interval: BigNumberish;
  unitSize: BigNumberish;
  tokenAddress: AddressLike;
  isBlacklist: boolean;
};

export type DutchInviteStructOutput = [
  price: bigint,
  reservePrice: bigint,
  delta: bigint,
  start: bigint,
  end: bigint,
  limit: bigint,
  maxSupply: bigint,
  interval: bigint,
  unitSize: bigint,
  tokenAddress: string,
  isBlacklist: boolean
] & {
  price: bigint;
  reservePrice: bigint;
  delta: bigint;
  start: bigint;
  end: bigint;
  limit: bigint;
  maxSupply: bigint;
  interval: bigint;
  unitSize: bigint;
  tokenAddress: string;
  isBlacklist: boolean;
};

export type InviteStruct = {
  price: BigNumberish;
  start: BigNumberish;
  end: BigNumberish;
  limit: BigNumberish;
  maxSupply: BigNumberish;
  unitSize: BigNumberish;
  tokenAddress: AddressLike;
  isBlacklist: boolean;
};

export type InviteStructOutput = [
  price: bigint,
  start: bigint,
  end: bigint,
  limit: bigint,
  maxSupply: bigint,
  unitSize: bigint,
  tokenAddress: string,
  isBlacklist: boolean
] & {
  price: bigint;
  start: bigint;
  end: bigint;
  limit: bigint;
  maxSupply: bigint;
  unitSize: bigint;
  tokenAddress: string;
  isBlacklist: boolean;
};

export declare namespace IERC721AUpgradeable {
  export type TokenOwnershipStruct = {
    addr: AddressLike;
    startTimestamp: BigNumberish;
    burned: boolean;
    extraData: BigNumberish;
  };

  export type TokenOwnershipStructOutput = [
    addr: string,
    startTimestamp: bigint,
    burned: boolean,
    extraData: bigint
  ] & {
    addr: string;
    startTimestamp: bigint;
    burned: boolean;
    extraData: bigint;
  };
}

export interface ArchetypeInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "affiliateBalance"
      | "affiliateBalanceToken"
      | "approve"
      | "balanceOf"
      | "batchMintTo"
      | "burnInvites"
      | "burnToMint"
      | "computePrice"
      | "config"
      | "explicitOwnershipOf"
      | "explicitOwnershipsOf"
      | "getApproved"
      | "initialize"
      | "invites"
      | "isApprovedForAll"
      | "listSupply"
      | "lockAffiliateFee"
      | "lockDiscounts"
      | "lockMaxSupply"
      | "lockOwnerAltPayout"
      | "lockURI"
      | "mint"
      | "mintTo"
      | "minted"
      | "name"
      | "options"
      | "owner"
      | "ownerBalance"
      | "ownerBalanceToken"
      | "ownerOf"
      | "payoutConfig"
      | "platform"
      | "renounceOwnership"
      | "royaltyInfo"
      | "safeTransferFrom(address,address,uint256)"
      | "safeTransferFrom(address,address,uint256,bytes)"
      | "setAffiliateFee"
      | "setApprovalForAll"
      | "setBaseURI"
      | "setBurnInvite"
      | "setDefaultRoyalty"
      | "setDiscounts"
      | "setDutchInvite"
      | "setInvite"
      | "setMaxBatchSize"
      | "setMaxSupply"
      | "setOwnerAltPayout"
      | "supportsInterface"
      | "symbol"
      | "tokenURI"
      | "tokensOfOwner"
      | "tokensOfOwnerIn"
      | "totalSupply"
      | "transferFrom"
      | "transferOwnership"
      | "withdraw"
      | "withdrawAffiliate"
      | "withdrawTokens"
      | "withdrawTokensAffiliate"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "Approval"
      | "ApprovalForAll"
      | "BurnInvited"
      | "ConsecutiveTransfer"
      | "Initialized"
      | "Invited"
      | "OwnershipTransferred"
      | "Referral"
      | "Transfer"
      | "Withdrawal"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "affiliateBalance",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "affiliateBalanceToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "batchMintTo",
    values: [AuthStruct, AddressLike[], BigNumberish[], AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "burnInvites",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "burnToMint",
    values: [AuthStruct, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "computePrice",
    values: [BytesLike, BigNumberish, boolean]
  ): string;
  encodeFunctionData(functionFragment: "config", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "explicitOwnershipOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "explicitOwnershipsOf",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproved",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, string, ConfigStruct, PayoutConfigStruct, AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "invites", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "listSupply",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "lockAffiliateFee",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "lockDiscounts",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "lockMaxSupply",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "lockOwnerAltPayout",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "lockURI", values: [string]): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [AuthStruct, BigNumberish, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mintTo",
    values: [AuthStruct, BigNumberish, AddressLike, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "minted",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "options", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ownerBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ownerBalanceToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "ownerOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "payoutConfig",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "platform", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "royaltyInfo",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom(address,address,uint256)",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
    values: [AddressLike, AddressLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setAffiliateFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(functionFragment: "setBaseURI", values: [string]): string;
  encodeFunctionData(
    functionFragment: "setBurnInvite",
    values: [BytesLike, BytesLike, BurnInviteStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setDefaultRoyalty",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setDiscounts",
    values: [DiscountStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setDutchInvite",
    values: [BytesLike, BytesLike, DutchInviteStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setInvite",
    values: [BytesLike, BytesLike, InviteStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxBatchSize",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxSupply",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwnerAltPayout",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "tokenURI",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensOfOwner",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensOfOwnerIn",
    values: [AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "withdraw", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdrawAffiliate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawTokens",
    values: [AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawTokensAffiliate",
    values: [AddressLike[]]
  ): string;

  decodeFunctionResult(
    functionFragment: "affiliateBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "affiliateBalanceToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "batchMintTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "burnInvites",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "burnToMint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "computePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "config", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "explicitOwnershipOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "explicitOwnershipsOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "invites", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "listSupply", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lockAffiliateFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lockDiscounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lockMaxSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lockOwnerAltPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lockURI", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintTo", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "minted", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "options", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ownerBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ownerBalanceToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ownerOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "payoutConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "platform", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "royaltyInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom(address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAffiliateFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setBaseURI", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setBurnInvite",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDefaultRoyalty",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDiscounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDutchInvite",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setInvite", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setMaxBatchSize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOwnerAltPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokenURI", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokensOfOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensOfOwnerIn",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawAffiliate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawTokensAffiliate",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    approved: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [owner: string, approved: string, tokenId: bigint];
  export interface OutputObject {
    owner: string;
    approved: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ApprovalForAllEvent {
  export type InputTuple = [
    owner: AddressLike,
    operator: AddressLike,
    approved: boolean
  ];
  export type OutputTuple = [
    owner: string,
    operator: string,
    approved: boolean
  ];
  export interface OutputObject {
    owner: string;
    operator: string;
    approved: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BurnInvitedEvent {
  export type InputTuple = [key: BytesLike, cid: BytesLike];
  export type OutputTuple = [key: string, cid: string];
  export interface OutputObject {
    key: string;
    cid: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ConsecutiveTransferEvent {
  export type InputTuple = [
    fromTokenId: BigNumberish,
    toTokenId: BigNumberish,
    from: AddressLike,
    to: AddressLike
  ];
  export type OutputTuple = [
    fromTokenId: bigint,
    toTokenId: bigint,
    from: string,
    to: string
  ];
  export interface OutputObject {
    fromTokenId: bigint;
    toTokenId: bigint;
    from: string;
    to: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InitializedEvent {
  export type InputTuple = [version: BigNumberish];
  export type OutputTuple = [version: bigint];
  export interface OutputObject {
    version: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InvitedEvent {
  export type InputTuple = [key: BytesLike, cid: BytesLike];
  export type OutputTuple = [key: string, cid: string];
  export interface OutputObject {
    key: string;
    cid: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ReferralEvent {
  export type InputTuple = [
    affiliate: AddressLike,
    token: AddressLike,
    wad: BigNumberish,
    numMints: BigNumberish
  ];
  export type OutputTuple = [
    affiliate: string,
    token: string,
    wad: bigint,
    numMints: bigint
  ];
  export interface OutputObject {
    affiliate: string;
    token: string;
    wad: bigint;
    numMints: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, tokenId: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace WithdrawalEvent {
  export type InputTuple = [
    src: AddressLike,
    token: AddressLike,
    wad: BigNumberish
  ];
  export type OutputTuple = [src: string, token: string, wad: bigint];
  export interface OutputObject {
    src: string;
    token: string;
    wad: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Archetype extends BaseContract {
  connect(runner?: ContractRunner | null): Archetype;
  waitForDeployment(): Promise<this>;

  interface: ArchetypeInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  affiliateBalance: TypedContractMethod<
    [affiliate: AddressLike],
    [bigint],
    "view"
  >;

  affiliateBalanceToken: TypedContractMethod<
    [affiliate: AddressLike, token: AddressLike],
    [bigint],
    "view"
  >;

  approve: TypedContractMethod<
    [to: AddressLike, tokenId: BigNumberish],
    [void],
    "payable"
  >;

  balanceOf: TypedContractMethod<[owner: AddressLike], [bigint], "view">;

  batchMintTo: TypedContractMethod<
    [
      auth: AuthStruct,
      toList: AddressLike[],
      quantityList: BigNumberish[],
      affiliate: AddressLike,
      signature: BytesLike
    ],
    [void],
    "payable"
  >;

  burnInvites: TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        string,
        bigint,
        boolean,
        bigint,
        bigint,
        bigint,
        bigint
      ] & {
        burnErc721: string;
        burnAddress: string;
        tokenAddress: string;
        price: bigint;
        reversed: boolean;
        ratio: bigint;
        start: bigint;
        end: bigint;
        limit: bigint;
      }
    ],
    "view"
  >;

  burnToMint: TypedContractMethod<
    [auth: AuthStruct, tokenIds: BigNumberish[]],
    [void],
    "payable"
  >;

  computePrice: TypedContractMethod<
    [key: BytesLike, quantity: BigNumberish, affiliateUsed: boolean],
    [bigint],
    "view"
  >;

  config: TypedContractMethod<
    [],
    [
      [string, string, bigint, bigint, bigint, bigint, DiscountStructOutput] & {
        baseUri: string;
        affiliateSigner: string;
        maxSupply: bigint;
        maxBatchSize: bigint;
        affiliateFee: bigint;
        defaultRoyalty: bigint;
        discounts: DiscountStructOutput;
      }
    ],
    "view"
  >;

  explicitOwnershipOf: TypedContractMethod<
    [tokenId: BigNumberish],
    [IERC721AUpgradeable.TokenOwnershipStructOutput],
    "view"
  >;

  explicitOwnershipsOf: TypedContractMethod<
    [tokenIds: BigNumberish[]],
    [IERC721AUpgradeable.TokenOwnershipStructOutput[]],
    "view"
  >;

  getApproved: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  initialize: TypedContractMethod<
    [
      name: string,
      symbol: string,
      config_: ConfigStruct,
      payoutConfig_: PayoutConfigStruct,
      _receiver: AddressLike
    ],
    [void],
    "nonpayable"
  >;

  invites: TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        boolean
      ] & {
        price: bigint;
        reservePrice: bigint;
        delta: bigint;
        start: bigint;
        end: bigint;
        limit: bigint;
        maxSupply: bigint;
        interval: bigint;
        unitSize: bigint;
        tokenAddress: string;
        isBlacklist: boolean;
      }
    ],
    "view"
  >;

  isApprovedForAll: TypedContractMethod<
    [owner: AddressLike, operator: AddressLike],
    [boolean],
    "view"
  >;

  listSupply: TypedContractMethod<[key: BytesLike], [bigint], "view">;

  lockAffiliateFee: TypedContractMethod<
    [password: string],
    [void],
    "nonpayable"
  >;

  lockDiscounts: TypedContractMethod<[password: string], [void], "nonpayable">;

  lockMaxSupply: TypedContractMethod<[password: string], [void], "nonpayable">;

  lockOwnerAltPayout: TypedContractMethod<[], [void], "nonpayable">;

  lockURI: TypedContractMethod<[password: string], [void], "nonpayable">;

  mint: TypedContractMethod<
    [
      auth: AuthStruct,
      quantity: BigNumberish,
      affiliate: AddressLike,
      signature: BytesLike
    ],
    [void],
    "payable"
  >;

  mintTo: TypedContractMethod<
    [
      auth: AuthStruct,
      quantity: BigNumberish,
      to: AddressLike,
      affiliate: AddressLike,
      signature: BytesLike
    ],
    [void],
    "payable"
  >;

  minted: TypedContractMethod<
    [minter: AddressLike, key: BytesLike],
    [bigint],
    "view"
  >;

  name: TypedContractMethod<[], [string], "view">;

  options: TypedContractMethod<
    [],
    [
      [boolean, boolean, boolean, boolean, boolean] & {
        uriLocked: boolean;
        maxSupplyLocked: boolean;
        affiliateFeeLocked: boolean;
        discountsLocked: boolean;
        ownerAltPayoutLocked: boolean;
      }
    ],
    "view"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  ownerBalance: TypedContractMethod<[], [bigint], "view">;

  ownerBalanceToken: TypedContractMethod<
    [token: AddressLike],
    [bigint],
    "view"
  >;

  ownerOf: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  payoutConfig: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, string, string, string] & {
        ownerBps: bigint;
        platformBps: bigint;
        partnerBps: bigint;
        superAffiliateBps: bigint;
        partner: string;
        superAffiliate: string;
        ownerAltPayout: string;
      }
    ],
    "view"
  >;

  platform: TypedContractMethod<[], [string], "view">;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  royaltyInfo: TypedContractMethod<
    [tokenId: BigNumberish, salePrice: BigNumberish],
    [[string, bigint]],
    "view"
  >;

  "safeTransferFrom(address,address,uint256)": TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "payable"
  >;

  "safeTransferFrom(address,address,uint256,bytes)": TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      tokenId: BigNumberish,
      _data: BytesLike
    ],
    [void],
    "payable"
  >;

  setAffiliateFee: TypedContractMethod<
    [affiliateFee: BigNumberish],
    [void],
    "nonpayable"
  >;

  setApprovalForAll: TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;

  setBaseURI: TypedContractMethod<[baseUri: string], [void], "nonpayable">;

  setBurnInvite: TypedContractMethod<
    [_key: BytesLike, _cid: BytesLike, _burnInvite: BurnInviteStruct],
    [void],
    "nonpayable"
  >;

  setDefaultRoyalty: TypedContractMethod<
    [receiver: AddressLike, feeNumerator: BigNumberish],
    [void],
    "nonpayable"
  >;

  setDiscounts: TypedContractMethod<
    [discounts: DiscountStruct],
    [void],
    "nonpayable"
  >;

  setDutchInvite: TypedContractMethod<
    [_key: BytesLike, _cid: BytesLike, _dutchInvite: DutchInviteStruct],
    [void],
    "nonpayable"
  >;

  setInvite: TypedContractMethod<
    [_key: BytesLike, _cid: BytesLike, _invite: InviteStruct],
    [void],
    "nonpayable"
  >;

  setMaxBatchSize: TypedContractMethod<
    [maxBatchSize: BigNumberish],
    [void],
    "nonpayable"
  >;

  setMaxSupply: TypedContractMethod<
    [maxSupply: BigNumberish, password: string],
    [void],
    "nonpayable"
  >;

  setOwnerAltPayout: TypedContractMethod<
    [ownerAltPayout: AddressLike],
    [void],
    "nonpayable"
  >;

  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  symbol: TypedContractMethod<[], [string], "view">;

  tokenURI: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  tokensOfOwner: TypedContractMethod<[owner: AddressLike], [bigint[]], "view">;

  tokensOfOwnerIn: TypedContractMethod<
    [owner: AddressLike, start: BigNumberish, stop: BigNumberish],
    [bigint[]],
    "view"
  >;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "payable"
  >;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  withdraw: TypedContractMethod<[], [void], "nonpayable">;

  withdrawAffiliate: TypedContractMethod<[], [void], "nonpayable">;

  withdrawTokens: TypedContractMethod<
    [tokens: AddressLike[]],
    [void],
    "nonpayable"
  >;

  withdrawTokensAffiliate: TypedContractMethod<
    [tokens: AddressLike[]],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "affiliateBalance"
  ): TypedContractMethod<[affiliate: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "affiliateBalanceToken"
  ): TypedContractMethod<
    [affiliate: AddressLike, token: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [to: AddressLike, tokenId: BigNumberish],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[owner: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "batchMintTo"
  ): TypedContractMethod<
    [
      auth: AuthStruct,
      toList: AddressLike[],
      quantityList: BigNumberish[],
      affiliate: AddressLike,
      signature: BytesLike
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "burnInvites"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        string,
        bigint,
        boolean,
        bigint,
        bigint,
        bigint,
        bigint
      ] & {
        burnErc721: string;
        burnAddress: string;
        tokenAddress: string;
        price: bigint;
        reversed: boolean;
        ratio: bigint;
        start: bigint;
        end: bigint;
        limit: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "burnToMint"
  ): TypedContractMethod<
    [auth: AuthStruct, tokenIds: BigNumberish[]],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "computePrice"
  ): TypedContractMethod<
    [key: BytesLike, quantity: BigNumberish, affiliateUsed: boolean],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "config"
  ): TypedContractMethod<
    [],
    [
      [string, string, bigint, bigint, bigint, bigint, DiscountStructOutput] & {
        baseUri: string;
        affiliateSigner: string;
        maxSupply: bigint;
        maxBatchSize: bigint;
        affiliateFee: bigint;
        defaultRoyalty: bigint;
        discounts: DiscountStructOutput;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "explicitOwnershipOf"
  ): TypedContractMethod<
    [tokenId: BigNumberish],
    [IERC721AUpgradeable.TokenOwnershipStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "explicitOwnershipsOf"
  ): TypedContractMethod<
    [tokenIds: BigNumberish[]],
    [IERC721AUpgradeable.TokenOwnershipStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getApproved"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "initialize"
  ): TypedContractMethod<
    [
      name: string,
      symbol: string,
      config_: ConfigStruct,
      payoutConfig_: PayoutConfigStruct,
      _receiver: AddressLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "invites"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        boolean
      ] & {
        price: bigint;
        reservePrice: bigint;
        delta: bigint;
        start: bigint;
        end: bigint;
        limit: bigint;
        maxSupply: bigint;
        interval: bigint;
        unitSize: bigint;
        tokenAddress: string;
        isBlacklist: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "isApprovedForAll"
  ): TypedContractMethod<
    [owner: AddressLike, operator: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "listSupply"
  ): TypedContractMethod<[key: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "lockAffiliateFee"
  ): TypedContractMethod<[password: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "lockDiscounts"
  ): TypedContractMethod<[password: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "lockMaxSupply"
  ): TypedContractMethod<[password: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "lockOwnerAltPayout"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "lockURI"
  ): TypedContractMethod<[password: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "mint"
  ): TypedContractMethod<
    [
      auth: AuthStruct,
      quantity: BigNumberish,
      affiliate: AddressLike,
      signature: BytesLike
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "mintTo"
  ): TypedContractMethod<
    [
      auth: AuthStruct,
      quantity: BigNumberish,
      to: AddressLike,
      affiliate: AddressLike,
      signature: BytesLike
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "minted"
  ): TypedContractMethod<
    [minter: AddressLike, key: BytesLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "options"
  ): TypedContractMethod<
    [],
    [
      [boolean, boolean, boolean, boolean, boolean] & {
        uriLocked: boolean;
        maxSupplyLocked: boolean;
        affiliateFeeLocked: boolean;
        discountsLocked: boolean;
        ownerAltPayoutLocked: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "ownerBalance"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "ownerBalanceToken"
  ): TypedContractMethod<[token: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "ownerOf"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "payoutConfig"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, string, string, string] & {
        ownerBps: bigint;
        platformBps: bigint;
        partnerBps: bigint;
        superAffiliateBps: bigint;
        partner: string;
        superAffiliate: string;
        ownerAltPayout: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "platform"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "royaltyInfo"
  ): TypedContractMethod<
    [tokenId: BigNumberish, salePrice: BigNumberish],
    [[string, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "safeTransferFrom(address,address,uint256)"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "safeTransferFrom(address,address,uint256,bytes)"
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      tokenId: BigNumberish,
      _data: BytesLike
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "setAffiliateFee"
  ): TypedContractMethod<[affiliateFee: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setApprovalForAll"
  ): TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setBaseURI"
  ): TypedContractMethod<[baseUri: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setBurnInvite"
  ): TypedContractMethod<
    [_key: BytesLike, _cid: BytesLike, _burnInvite: BurnInviteStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setDefaultRoyalty"
  ): TypedContractMethod<
    [receiver: AddressLike, feeNumerator: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setDiscounts"
  ): TypedContractMethod<[discounts: DiscountStruct], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setDutchInvite"
  ): TypedContractMethod<
    [_key: BytesLike, _cid: BytesLike, _dutchInvite: DutchInviteStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setInvite"
  ): TypedContractMethod<
    [_key: BytesLike, _cid: BytesLike, _invite: InviteStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setMaxBatchSize"
  ): TypedContractMethod<[maxBatchSize: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setMaxSupply"
  ): TypedContractMethod<
    [maxSupply: BigNumberish, password: string],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setOwnerAltPayout"
  ): TypedContractMethod<[ownerAltPayout: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "tokenURI"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "tokensOfOwner"
  ): TypedContractMethod<[owner: AddressLike], [bigint[]], "view">;
  getFunction(
    nameOrSignature: "tokensOfOwnerIn"
  ): TypedContractMethod<
    [owner: AddressLike, start: BigNumberish, stop: BigNumberish],
    [bigint[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "withdraw"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "withdrawAffiliate"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "withdrawTokens"
  ): TypedContractMethod<[tokens: AddressLike[]], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "withdrawTokensAffiliate"
  ): TypedContractMethod<[tokens: AddressLike[]], [void], "nonpayable">;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "ApprovalForAll"
  ): TypedContractEvent<
    ApprovalForAllEvent.InputTuple,
    ApprovalForAllEvent.OutputTuple,
    ApprovalForAllEvent.OutputObject
  >;
  getEvent(
    key: "BurnInvited"
  ): TypedContractEvent<
    BurnInvitedEvent.InputTuple,
    BurnInvitedEvent.OutputTuple,
    BurnInvitedEvent.OutputObject
  >;
  getEvent(
    key: "ConsecutiveTransfer"
  ): TypedContractEvent<
    ConsecutiveTransferEvent.InputTuple,
    ConsecutiveTransferEvent.OutputTuple,
    ConsecutiveTransferEvent.OutputObject
  >;
  getEvent(
    key: "Initialized"
  ): TypedContractEvent<
    InitializedEvent.InputTuple,
    InitializedEvent.OutputTuple,
    InitializedEvent.OutputObject
  >;
  getEvent(
    key: "Invited"
  ): TypedContractEvent<
    InvitedEvent.InputTuple,
    InvitedEvent.OutputTuple,
    InvitedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "Referral"
  ): TypedContractEvent<
    ReferralEvent.InputTuple,
    ReferralEvent.OutputTuple,
    ReferralEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;
  getEvent(
    key: "Withdrawal"
  ): TypedContractEvent<
    WithdrawalEvent.InputTuple,
    WithdrawalEvent.OutputTuple,
    WithdrawalEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "ApprovalForAll(address,address,bool)": TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;
    ApprovalForAll: TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;

    "BurnInvited(bytes32,bytes32)": TypedContractEvent<
      BurnInvitedEvent.InputTuple,
      BurnInvitedEvent.OutputTuple,
      BurnInvitedEvent.OutputObject
    >;
    BurnInvited: TypedContractEvent<
      BurnInvitedEvent.InputTuple,
      BurnInvitedEvent.OutputTuple,
      BurnInvitedEvent.OutputObject
    >;

    "ConsecutiveTransfer(uint256,uint256,address,address)": TypedContractEvent<
      ConsecutiveTransferEvent.InputTuple,
      ConsecutiveTransferEvent.OutputTuple,
      ConsecutiveTransferEvent.OutputObject
    >;
    ConsecutiveTransfer: TypedContractEvent<
      ConsecutiveTransferEvent.InputTuple,
      ConsecutiveTransferEvent.OutputTuple,
      ConsecutiveTransferEvent.OutputObject
    >;

    "Initialized(uint64)": TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;
    Initialized: TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;

    "Invited(bytes32,bytes32)": TypedContractEvent<
      InvitedEvent.InputTuple,
      InvitedEvent.OutputTuple,
      InvitedEvent.OutputObject
    >;
    Invited: TypedContractEvent<
      InvitedEvent.InputTuple,
      InvitedEvent.OutputTuple,
      InvitedEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "Referral(address,address,uint128,uint256)": TypedContractEvent<
      ReferralEvent.InputTuple,
      ReferralEvent.OutputTuple,
      ReferralEvent.OutputObject
    >;
    Referral: TypedContractEvent<
      ReferralEvent.InputTuple,
      ReferralEvent.OutputTuple,
      ReferralEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;

    "Withdrawal(address,address,uint128)": TypedContractEvent<
      WithdrawalEvent.InputTuple,
      WithdrawalEvent.OutputTuple,
      WithdrawalEvent.OutputObject
    >;
    Withdrawal: TypedContractEvent<
      WithdrawalEvent.InputTuple,
      WithdrawalEvent.OutputTuple,
      WithdrawalEvent.OutputObject
    >;
  };
}
